package main

import (
	"crypto/rand"
	"encoding/base64"
	"fmt"
	"os"
	"path/filepath"

	"github.com/spf13/cobra"
	"golang.org/x/crypto/bcrypt"
)

var (
	forceOverwrite bool
	outputPath     string
)

var genenvCmd = &cobra.Command{
	Use:   "genenv",
	Short: "Generate .env file with secure authentication credentials",
	Long: `Generate a .env file with randomly generated secure credentials for Basic Authentication.

This command creates a .env file containing:
  - BASIC_AUTH_USERNAME: A random username (12 characters)
  - BASIC_AUTH_PASSWORD_HASH: A bcrypt hash of a random password (24 characters)

The password is hashed using bcrypt before being written to the file. The plaintext
password is displayed once during generation - save it securely (e.g., password manager).

Example:
  coinops genenv                    # Creates .env in current directory
  coinops genenv -o /path/to/.env   # Creates .env at specified path
  coinops genenv --force            # Overwrite existing .env file`,
	RunE: runGenenv,
}

func init() {
	rootCmd.AddCommand(genenvCmd)

	genenvCmd.Flags().BoolVarP(&forceOverwrite, "force", "f", false, "Overwrite existing .env file")
	genenvCmd.Flags().StringVarP(&outputPath, "output", "o", ".env", "Output path for .env file")
}

func runGenenv(cmd *cobra.Command, args []string) error {
	// Resolve absolute path
	absPath, err := filepath.Abs(outputPath)
	if err != nil {
		return fmt.Errorf("failed to resolve output path: %w", err)
	}

	// Check if file exists
	if _, err := os.Stat(absPath); err == nil && !forceOverwrite {
		return fmt.Errorf("file already exists: %s (use --force to overwrite)", absPath)
	}

	// Generate secure random credentials
	username, err := generateSecureString(12)
	if err != nil {
		return fmt.Errorf("failed to generate username: %w", err)
	}

	password, err := generateSecureString(24)
	if err != nil {
		return fmt.Errorf("failed to generate password: %w", err)
	}

	// Hash the password using bcrypt (cost 10 is the default, good balance of security/performance)
	passwordHash, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
	if err != nil {
		return fmt.Errorf("failed to hash password: %w", err)
	}

	// Create .env content
	// Note: Hash must be single-quoted to prevent $ being interpreted as variable reference
	content := fmt.Sprintf(`# CoinOps Dashboard Authentication Credentials
# Generated by: coinops genenv
# DO NOT commit this file to version control!

# Basic Authentication
# Username is stored in plaintext (not sensitive)
BASIC_AUTH_USERNAME=%s

# Password is stored as a bcrypt hash (salted, one-way hash)
# Original password cannot be recovered from this hash
# Single quotes prevent $ from being interpreted as variable reference
BASIC_AUTH_PASSWORD_HASH='%s'

# This file is automatically loaded by 'coinops serve'
# For Docker: docker run --env-file .env ...
`, username, string(passwordHash))

	// Write to file with restricted permissions (0600 = rw-------)
	if err := os.WriteFile(absPath, []byte(content), 0600); err != nil {
		return fmt.Errorf("failed to write .env file: %w", err)
	}

	fmt.Printf("âœ“ Generated .env file: %s\n\n", absPath)
	fmt.Println("=================================================================")
	fmt.Println("SAVE THESE CREDENTIALS NOW - THE PASSWORD WON'T BE SHOWN AGAIN")
	fmt.Println("=================================================================")
	fmt.Printf("\n  Username: %s\n", username)
	fmt.Printf("  Password: %s\n\n", password)
	fmt.Println("The password has been hashed with bcrypt before storage.")
	fmt.Println("Only the hash is stored in .env - the plaintext password above")
	fmt.Println("is shown only once. Save it securely (e.g., password manager).")
	fmt.Println("\nTo use these credentials:")
	fmt.Println("  1. Ensure security.basic_auth.enabled = true in config.yaml")
	fmt.Println("  2. Start server: ./coinops serve")
	fmt.Println("     (The .env file is loaded automatically)")
	fmt.Println("\nIMPORTANT:")
	fmt.Println("  - Add .env to .gitignore to prevent committing secrets!")
	fmt.Println("  - The .env file contains a bcrypt hash, NOT the plaintext password")
	fmt.Println("  - If you lose the password, run 'coinops genenv --force' to regenerate")

	return nil
}

// generateSecureString creates a cryptographically secure random string
// using base64url encoding (URL-safe, no padding)
func generateSecureString(length int) (string, error) {
	// For base64url, 3 bytes = 4 characters, so we need (length * 3 / 4) bytes
	// Round up to ensure we get at least 'length' characters
	numBytes := (length*3 + 3) / 4

	bytes := make([]byte, numBytes)
	if _, err := rand.Read(bytes); err != nil {
		return "", err
	}

	// Use URL-safe base64 encoding (no padding)
	encoded := base64.RawURLEncoding.EncodeToString(bytes)

	// Trim to exact length
	if len(encoded) > length {
		encoded = encoded[:length]
	}

	return encoded, nil
}
